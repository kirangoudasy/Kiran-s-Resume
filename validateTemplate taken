srv.on('CREATE', "ReportFileStorage", async (req) => {
  const tx = cds.transaction(req);

  try {
    // --------------------------------------------------
    // 1. CREATE ReportFileStorage (WITHOUT JSON_DATA)
    // --------------------------------------------------
    const payload = { ...req.data };
    delete payload.JSON_DATA;

    const result = await tx.create(
      'com.scb.fileupload.master.ReportFileStorage'
    ).entries(payload);

    const uuid = result?.ID || req.data.ID;

    // --------------------------------------------------
    // 2. READ FILE CONTENT
    // --------------------------------------------------
    const fileRows = await tx.run(
      SELECT.from('com.scb.fileupload.master.ReportFileStorage')
        .columns('FILE_CONTENT', 'MODULE_NAME', 'SUB_MODULE_NAME', 'LOAD_TEMPLATE')
        .where({ ID: uuid })
    );

    if (!fileRows.length) {
      req.error(404, 'File not found');
    }

    const { FILE_CONTENT, MODULE_NAME, SUB_MODULE_NAME, LOAD_TEMPLATE } = fileRows[0];

    const chunks = [];
    for await (const chunk of FILE_CONTENT) {
      chunks.push(chunk);
    }
    const buffer = Buffer.concat(chunks);

    // --------------------------------------------------
    // 3. EXCEL → JSON
    // --------------------------------------------------
    const workbook = xlsx.read(buffer, { type: 'buffer' });
    const sheet = workbook.Sheets[workbook.SheetNames[0]];
    const jsonData = xlsx.utils.sheet_to_json(sheet, { raw: true, defval: "" });

    // --------------------------------------------------
    // 4. DATE / TIME NORMALIZATION (UNCHANGED)
    // --------------------------------------------------
    const loadMap = await tx.run(
      SELECT.from('com.scb.fileupload.master.LoadMap')
        .columns('COLUMN_NAME', 'COLUMN_DATATYPE')
        .where({ MODULE_NAME, SUB_MODULE_NAME, LOAD_TEMPLATE })
        .orderBy('LOAD_COLUMN_SEQ')
    );

    const typeMap = loadMap.reduce((a, c) => {
      a[c.COLUMN_NAME] = c.COLUMN_DATATYPE;
      return a;
    }, {});

    const dateCols = Object.keys(typeMap).filter(c => typeMap[c] === 'DATE');
    const timeCols = Object.keys(typeMap).filter(c => typeMap[c] === 'TIME');

    jsonData.forEach(row => {
      dateCols.forEach(c => {
        const v = Datechange(row[c]);
        if (v) row[c] = v;
      });
      timeCols.forEach(c => {
        const v = convertTime(row[c]);
        if (v) row[c] = v;
      });
    });

    const jsonString = JSON.stringify(jsonData);

    // --------------------------------------------------
    // 5. INSERT INTO DUMMY
    // --------------------------------------------------
    await tx.run(
      INSERT.into('com.scb.fileupload.master.Dummy').entries({
        ID: uuid,
        JSON_DATA: jsonString
      })
    );

    // --------------------------------------------------
    // 6. CALL VALIDATOR (✔ CORRECT WAY)
    // --------------------------------------------------
    await tx.run(`
      CALL GENERIC_DATA_VALIDATOR(
        '${uuid}',
        '${MODULE_NAME}',
        '${SUB_MODULE_NAME}',
        '${LOAD_TEMPLATE}',
        ?, ?
      )
    `);

    const procResult = await tx.run(`
      SELECT O_STATUS AS STATUS, O_MESSAGE AS MESSAGE FROM DUMMY
    `);

    const STATUS = procResult[0]?.STATUS;
    const MESSAGE = procResult[0]?.MESSAGE;

    // --------------------------------------------------
    // 7. FAILURE → CLEANUP
    // --------------------------------------------------
    if (STATUS === 'E') {
      await tx.run(
        DELETE.from('com.scb.fileupload.master.Dummy')
          .where({ ID: uuid })
      );

      return {
        STATUS: 'E',
        MESSAGE: MESSAGE
      };
    }

    // --------------------------------------------------
    // 8. SUCCESS → MOVE DATA
    // --------------------------------------------------
    await tx.run(
      UPDATE('com.scb.fileupload.master.ReportFileStorage')
        .set({ JSON_DATA: jsonString })
        .where({ ID: uuid })
    );

    await tx.run(
      DELETE.from('com.scb.fileupload.master.Dummy')
        .where({ ID: uuid })
    );

    return {
      STATUS: 'S',
      MESSAGE: MESSAGE,
      ID: uuid
    };

  } catch (err) {
    console.error(err);
    req.error(500, err.message);
  }

  // ================= HELPERS =================

  function convertTime(value) {
    if (!value) return "";
    if (typeof value === "number" && value >= 0 && value < 1) {
      const s = Math.round(value * 86400);
      return `${String(Math.floor(s / 3600)).padStart(2, "0")}:${String(Math.floor((s % 3600) / 60)).padStart(2, "0")}:${String(s % 60).padStart(2, "0")}`;
    }
    const d = new Date("1970-01-01T" + value);
    return isNaN(d) ? "" : d.toISOString().substring(11, 19);
  }

  function Datechange(value) {
    if (!value) return "";
    if (typeof value === "number") {
      const d = new Date((value - 25569) * 86400 * 1000);
      return isNaN(d) ? "" : d.toISOString().substring(0, 10);
    }
    const d = new Date(value);
    return isNaN(d) ? "" : d.toISOString().substring(0, 10);
  }
});
