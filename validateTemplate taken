srv.on('CREATE', "ReportFileStorage", async (req) => {
  const tx = cds.tx(req); // ðŸ”´ FIX: single transaction

  try {
    const result = await tx
      .create("com.scb.fileupload.master.ReportFileStorage")
      .entries(req.data);

    const uuid = result?.ID || req.data.ID;

    const file = await tx.run(
      SELECT
        .from('com.scb.fileupload.master.ReportFileStorage')
        .columns('FILE_CONTENT', 'FILE_NAME', 'FILE_MIME_TYPE')
        .where({ ID: uuid })
    );

    if (!file || file.length === 0) {
      return req.error(404, 'File not found');
    }

    const { FILE_CONTENT } = file[0];

    const streamToBuffer = async (readableStream) => {
      const chunks = [];
      for await (const chunk of readableStream) {
        chunks.push(chunk);
      }
      return Buffer.concat(chunks);
    };

    const buffer = await streamToBuffer(FILE_CONTENT);

    const workbook = xlsx.read(buffer, { type: 'buffer' });
    const sheetName = workbook.SheetNames[0];
    const sheet = workbook.Sheets[sheetName];

    // Convert Excel to JSON
    const jsonData = xlsx.utils.sheet_to_json(sheet, { raw: true, defval: "" });

    // Fetch module, submodule, template
    const reportFileStorageList = await tx.run(
      SELECT
        .from('com.scb.fileupload.master.ReportFileStorage')
        .columns('MODULE_NAME', 'SUB_MODULE_NAME', 'LOAD_TEMPLATE')
        .where({ ID: uuid })
    );

    const reportFileStorageItem = reportFileStorageList[0];

    // Fetch column datatype mapping
    const loadTableList = await tx.run(
      SELECT
        .from('com.scb.fileupload.master.LoadMap')
        .columns('COLUMN_NAME', 'COLUMN_DATATYPE')
        .where({
          MODULE_NAME: reportFileStorageItem.MODULE_NAME,
          SUB_MODULE_NAME: reportFileStorageItem.SUB_MODULE_NAME,
          LOAD_TEMPLATE: reportFileStorageItem.LOAD_TEMPLATE
        })
        .orderBy('LOAD_COLUMN_SEQ')
    );

    const excepetedMap = loadTableList.reduce((acc, item) => {
      acc[item.COLUMN_NAME] = item.COLUMN_DATATYPE;
      return acc;
    }, {});

    // Date conversion
    const dateKeys = Object.entries(excepetedMap)
      .filter(([_, v]) => v === "DATE")
      .map(([k]) => k);

    if (dateKeys.length) {
      jsonData.forEach(row => {
        dateKeys.forEach(col => {
          const dateChange = Datechange(row[col]);
          if (dateChange) row[col] = dateChange;
        });
      });
    }

    // Time conversion
    const timeKeys = Object.entries(excepetedMap)
      .filter(([_, v]) => v === "TIME")
      .map(([k]) => k);

    if (timeKeys.length) {
      jsonData.forEach(row => {
        timeKeys.forEach(col => {
          const timeChange = convertTime(row[col]);
          if (timeChange) row[col] = timeChange;
        });
      });
    }

    const strJson = JSON.stringify(jsonData);

    /* ðŸ”´ FIX 1: CLEAN DUMMY BEFORE INSERT */
    await tx.run(
      DELETE.from('com.scb.fileupload.master.Dummy')
        .where({ ID: uuid })
    );

    /* ðŸ”´ INSERT INTO DUMMY */
    await tx.run(
      INSERT.into('com.scb.fileupload.master.Dummy').entries({
        ID: uuid,
        JSON_DATA: strJson
      })
    );

    /* ðŸ”´ FIX 2: CORRECT PROC CALL */
    const validatorResult = await tx.run(`
      DO BEGIN
        DECLARE v_status NVARCHAR(1);
        DECLARE v_message NVARCHAR(2000);

        CALL GENERIC_DATA_VALIDATOR(
          '${uuid}',
          '${reportFileStorageItem.MODULE_NAME}',
          '${reportFileStorageItem.SUB_MODULE_NAME}',
          '${reportFileStorageItem.LOAD_TEMPLATE}',
          v_status,
          v_message
        );

        SELECT :v_status AS O_STATUS, :v_message AS O_MESSAGE FROM DUMMY;
      END;
    `);

    const { O_STATUS, O_MESSAGE } = validatorResult[0];

    if (O_STATUS === 'E') {
      await tx.run(
        DELETE.from('com.scb.fileupload.master.Dummy')
          .where({ ID: uuid })
      );
      return req.error(400, O_MESSAGE);
    }

    /* ðŸ”´ MOVE DATA TO MAIN TABLE */
    await tx.run(
      UPDATE('com.scb.fileupload.master.ReportFileStorage')
        .set({ JSON_DATA: strJson })
        .where({ ID: uuid })
    );

    /* ðŸ”´ CLEAN DUMMY AFTER SUCCESS */
    await tx.run(
      DELETE.from('com.scb.fileupload.master.Dummy')
        .where({ ID: uuid })
    );

    return { ID: uuid };

  } catch (err) {
    console.error('Error during file upload:', err);

    // ðŸ”´ FIX 3: DO NOT CONVERT BUSINESS ERROR TO 500
    if (err.statusCode) {
      throw err;
    }

    return req.error(500, 'Failed to store file record.');
  }

  /* ================= HELPER FUNCTIONS (UNCHANGED) ================= */

  function convertTime(value) {
    if (!value) return "";

    if (typeof value === "number" && value >= 0 && value < 1) {
      const totalSeconds = Math.round(value * 86400);
      const hh = String(Math.floor(totalSeconds / 3600)).padStart(2, "0");
      const mm = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, "0");
      const ss = String(totalSeconds % 60).padStart(2, "0");
      return `${hh}:${mm}:${ss}`;
    }

    const str = String(value).trim();

    if (/^(?:[01]\d|2[0-3]):[0-5]\d$/.test(str)) return str + ":00";
    if (/^(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(str)) return str;
    if (/^(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d\.\d+$/.test(str))
      return str.split(".")[0];

    const ampmMatch = str.match(/^(\d{1,2}):(\d{2})\s?(AM|PM)$/i);
    if (ampmMatch) {
      let [_, h, m, ampm] = ampmMatch;
      h = Number(h);
      if (ampm.toUpperCase() === "PM" && h !== 12) h += 12;
      if (ampm.toUpperCase() === "AM" && h === 12) h = 0;
      return `${String(h).padStart(2, "0")}:${m}:00`;
    }

    const tryParse = new Date("1970-01-01T" + str);
    if (!isNaN(tryParse.getTime()))
      return tryParse.toISOString().split("T")[1].substring(0, 8);

    return "";
  }

  function Datechange(value) {
    if (!value) return "";

    if (typeof value === "number") {
      const excelDate = new Date((value - 25569) * 86400 * 1000);
      if (isNaN(excelDate.getTime())) return "";
      return excelDate.toISOString().split("T")[0];
    }

    const parsed = new Date(value);
    if (!isNaN(parsed.getTime()))
      return parsed.toISOString().split("T")[0];

    value = String(value).trim();
    const match = value.match(/^(\d{2})[-\/](\d{2})[-\/](\d{4})$/);

    if (match) {
      const [, dd, mm, yyyy] = match;
      const iso = `${yyyy}-${mm}-${dd}`;
      const d = new Date(iso);
      if (!isNaN(d.getTime())) return iso;
    }
    return "";
  }
});
