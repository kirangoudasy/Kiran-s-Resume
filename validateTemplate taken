 srv.on('CREATE', "ReportFileStorage", async (req) => {
    try {
      const result = await cds.tx(req).create("com.scb.fileupload.master.ReportFileStorage").entries(req.data);

      const uuid = result?.ID || req.data.ID;
      const db = cds.transaction(req);
      const file = await db.run(
        SELECT
          .from('com.scb.fileupload.master.ReportFileStorage')
          .columns('FILE_CONTENT', 'FILE_NAME', 'FILE_MIME_TYPE')
          .where({ ID: uuid })
      );

      if (!file || file.length === 0) {
        req.error(404, 'File not found');
      }

      const { FILE_CONTENT, FILE_NAME } = file[0];
      const streamToBuffer = async (readableStream) => {
        const chunks = [];
        for await (const chunk of readableStream) {
          chunks.push(chunk);
        }
        return Buffer.concat(chunks);
      };

      const buffer = await streamToBuffer(FILE_CONTENT); // FILE_CONTENT is Readable

      const base64Content = buffer.toString('base64');

      const workbook = xlsx.read(buffer, { type: 'buffer' });
      const sheetName = workbook.SheetNames[0];
      const sheet = workbook.Sheets[sheetName];

      //const jsonData = xlsx.utils.sheet_to_json(sheet); // All rows as JSON

      //Sundar -> code
      const jsonData = xlsx.utils.sheet_to_json(sheet, { raw: true, defval: "" });

      //get module, submodule, loadtemplate

      const reportFileStorageList = await db.run(
        SELECT
          .from('com.scb.fileupload.master.ReportFileStorage')
          .columns('MODULE_NAME', 'SUB_MODULE_NAME', 'LOAD_TEMPLATE')
          .where({ ID: uuid })
      );

      var reportFileStorageItem = reportFileStorageList[0];

      const loadTableList = await db.run(
        SELECT
          .from('com.scb.fileupload.master.LoadMap')
          .columns('COLUMN_NAME', 'COLUMN_DATATYPE')
          .where({
            MODULE_NAME: reportFileStorageItem.MODULE_NAME,
            SUB_MODULE_NAME: reportFileStorageItem.SUB_MODULE_NAME,
            LOAD_TEMPLATE: reportFileStorageItem.LOAD_TEMPLATE
          })
          .orderBy('LOAD_COLUMN_SEQ')
      );

      const excepetedMap = loadTableList.reduce((acc, item) => {
        const colName = item["COLUMN_NAME"];
        const dataType = item["COLUMN_DATATYPE"];
        acc[colName] = dataType;
        return acc;
      }, {});

      const dateKeys = Object.entries(excepetedMap)
        .filter(([k, v]) => v === "DATE")
        .map(([k]) => k);

      // Convert only known date columns

      if (dateKeys.length) {

        jsonData.forEach(row => {

          dateKeys.forEach(col => {

            const dateChange = Datechange(row[col]);
            if (dateChange) row[col] = dateChange;

          });
        });
      }

      const timeKeys = Object.entries(excepetedMap)
        .filter(([k, v]) => v === "TIME")
        .map(([k]) => k);

      if (timeKeys.length) {
        jsonData.forEach(row => {
          timeKeys.forEach(col => {
            const timeChange = convertTime(row[col]);
            if (timeChange) row[col] = timeChange;
          });
        });
      }


      const strJson = JSON.stringify(jsonData);

      //write update statement here

      try {
        await UPDATE('com.scb.fileupload.master.ReportFileStorage')
          .set({ JSON_DATA: strJson })
          .where({ ID: uuid });

        return { ID: uuid };
      } catch (error) {
        req.error(500, `Update failed: ${error.message}`);
      }

      return { ID: uuid };
    } catch (err) {
      console.error('Error during file upload:', err);
      req.error(500, 'Failed to store file record.');
    }


    function convertTime(value) {
      if (!value) return "";

      // Excel time serial (0 to 1)
      if (typeof value === "number" && value >= 0 && value < 1) {
        const totalSeconds = Math.round(value * 86400);
        const hh = String(Math.floor(totalSeconds / 3600)).padStart(2, "0");
        const mm = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, "0");
        const ss = String(totalSeconds % 60).padStart(2, "0");
        return `${hh}:${mm}:${ss}`;
      }

      const str = String(value).trim();

      // HH:mm
      if (/^(?:[01]\d|2[0-3]):[0-5]\d$/.test(str)) {
        return str + ":00";
      }

      // HH:mm:ss
      if (/^(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(str)) {
        return str;
      }

      // HH:mm:ss.SSS
      if (/^(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d\.\d+$/.test(str)) {
        return str.split(".")[0];
      }

      // h:mm AM/PM
      const ampmMatch = str.match(/^(\d{1,2}):(\d{2})\s?(AM|PM)$/i);
      if (ampmMatch) {
        let [_, h, m, ampm] = ampmMatch;
        h = Number(h);
        if (ampm.toUpperCase() === "PM" && h !== 12) h += 12;
        if (ampm.toUpperCase() === "AM" && h === 12) h = 0;
        return `${String(h).padStart(2, "0")}:${m}:00`;
      }

      // Try parsing time via Date
      const tryParse = new Date("1970-01-01T" + str);
      if (!isNaN(tryParse.getTime())) {
        return tryParse.toISOString().split("T")[1].substring(0, 8);
      }

      return "";
    }

    function Datechange(value) {
      if (!value) return "";

      if (typeof value === "number") {

        const excelDate = new Date((value - 25569) * 86400 * 1000);

        if (isNaN(excelDate.getTime())) return "";

        return excelDate.toISOString().split("T")[0];
      }

      const parsed = new Date(value);
      if (!isNaN(parsed.getTime())) {
        return parsed.toISOString().split("T")[0];
      }

      value = String(value).trim();

      const match = value.match(/^(\d{2})[-\/](\d{2})[-\/](\d{4})$/);
      if (match) {
        const [, dd, mm, yyyy] = match;

        if (+yyyy < 1 || +yyyy > 9999) return null;

        const iso = `${yyyy}-${mm}-${dd}`;
        const d = new Date(iso);
        if (!isNaN(d.getTime())) return iso;
        return "";

      }
      return "";
    }


  });
